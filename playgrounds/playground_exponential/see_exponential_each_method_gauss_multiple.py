"""
Module for the creation of 2d random SVFs and for the computations of
their exponential according to several methods.
In main_matrix_generated_multiple the same for an arbitrary number of svf
generated by matrix, with random input parameters.
"""

import numpy as np
import matplotlib.pyplot as plt
import time
import os

from transformations.s_vf import SVF

from visualizer.graphs_and_stats import custom_boxplot, custom_n_boxplots
from utils.aux_functions import remove_k

from utils.path_manager import path_to_results

##################
### Controller ###
##################

### Path manager

path_to_folder = os.path.join(path_to_results, 'exp_methods_results')

saved_file_index = 1

path_to_reordered_res_sca_sq_ground_for_boxplot    = os.path.join(path_to_folder,
                                                                  'reordered_res_sca_sq_ground_for_boxplot_' +
                                                                  str(saved_file_index) + '.npy')
path_to_reordered_res_sca_sq_pa_ground_for_boxplot = os.path.join(path_to_folder,
                                                                  'reordered_res_sca_sq_pa_ground_for_boxplot_' +
                                                                  str(saved_file_index) + '.npy')
path_to_reordered_res_euler_ground_for_boxplot     = os.path.join(path_to_folder,
                                                                  'reordered_res_euler_ground_for_boxplot_' +
                                                                  str(saved_file_index) + '.npy')
path_to_reordered_res_midpoint_ground_for_boxplot  = os.path.join(path_to_folder,
                                                                  'reordered_res_midpoint_ground_for_boxplot_' +
                                                                  str(saved_file_index) + '.npy')
path_to_reordered_res_euler_mod_ground_for_boxplot = os.path.join(path_to_folder,
                                                                  'reordered_res_euler_mod_ground_for_boxplot_' +
                                                                  str(saved_file_index) + '.npy')
path_to_reordered_res_heun_for_boxplot             = os.path.join(path_to_folder,
                                                                  'reordered_res_heun_for_boxplot_' +
                                                                  str(saved_file_index) + '.npy')
path_to_reordered_res_heun_mod_for_boxplot         = os.path.join(path_to_folder,
                                                                  'reordered_res_heun_mod_for_boxplot_' +
                                                                  str(saved_file_index) + '.npy')
path_to_reordered_res_r_k_4_for_boxplot            = os.path.join(path_to_folder,
                                                                  'reordered_res_r_k_4_for_boxplot' +
                                                                  str(saved_file_index) + '.npy')


### parameter manager:
shape = (12, 12, 1, 1, 2)
N = 200
spline_interpolation_order = 3

compute = True  # compute and save, or load only!

#############
### Model ###
#############

if compute:
    res_sca_sq_ground    = np.zeros([N, 9])
    res_sca_sq_pa_ground = np.zeros([N, 9])
    res_euler_ground     = np.zeros([N, 9])
    res_midpoint_ground  = np.zeros([N, 9])
    res_euler_mod_ground = np.zeros([N, 9])
    res_heun_ground      = np.zeros([N, 9])
    res_heun_mod_ground  = np.zeros([N, 9])
    res_r_k_4_ground     = np.zeros([N, 9])

    res_t = np.zeros([N, 8])

    for i in range(N):

        print str(i) + '/' + str(N)

        ### generate random vector fields

        svf_0 = SVF.generate_random_smooth(shape=shape)

        ### compute exponential with different available methods:

        # different number of steps per methods
        steps_per_method = [8, 8, 40, 10, 10, 10, 10, 8]
        # steps_per_method = [None, ]*8  # default number of steps

        ### compute exponential with different available methods:
        start = time.time()
        sdisp_ss      = svf_0.exponential(algorithm='ss',
                                          s_i_o=spline_interpolation_order,
                                          input_num_steps=steps_per_method[0])
        res_t[i, 0] = (time.time() - start)

        start = time.time()
        sdisp_ss_pa   = svf_0.exponential(algorithm='ss_pa',
                                          s_i_o=spline_interpolation_order,
                                          input_num_steps=steps_per_method[1])
        res_t[i, 1] = (time.time() - start)

        start = time.time()
        sdisp_euler   = svf_0.exponential(algorithm='euler',
                                          s_i_o=spline_interpolation_order,
                                          input_num_steps=steps_per_method[2])
        res_t[i, 2] = (time.time() - start)

        start = time.time()
        sdisp_mid_p   = svf_0.exponential(algorithm='midpoint',
                                          s_i_o=spline_interpolation_order,
                                          input_num_steps=steps_per_method[3])
        res_t[i, 3] = (time.time() - start)

        start = time.time()
        sdisp_euler_m = svf_0.exponential(algorithm='euler_mod',
                                          s_i_o=spline_interpolation_order,
                                          input_num_steps=steps_per_method[4])
        res_t[i, 4] = (time.time() - start)

        start = time.time()
        sdisp_heun    = svf_0.exponential(algorithm='heun',
                                          s_i_o=spline_interpolation_order,
                                          input_num_steps=steps_per_method[5])
        res_t[i, 5] = (time.time() - start)

        start = time.time()
        sdisp_heun_m  = svf_0.exponential(algorithm='heun_mod',
                                          s_i_o=spline_interpolation_order,
                                          input_num_steps=steps_per_method[6])
        res_t[i, 6] = (time.time() - start)

        start = time.time()
        sdisp_rk4     = svf_0.exponential(algorithm='rk4',
                                          s_i_o=spline_interpolation_order,
                                          input_num_steps=steps_per_method[7])
        res_t[i, 7] = (time.time() - start)

        # ----------------------------------------------------------
        # Consider each time a different method as ground truth:
        # ----------------------------------------------------------

        ### 1) Scaling squaring ground truth

        res_sca_sq_ground[i, 0] = svf_0.norm()
        res_sca_sq_ground[i, 1] = sdisp_ss.norm()
        res_sca_sq_ground[i, 2] = (sdisp_ss_pa -   sdisp_ss).norm(passe_partout_size=4)
        res_sca_sq_ground[i, 3] = (sdisp_euler -   sdisp_ss).norm(passe_partout_size=4)
        res_sca_sq_ground[i, 4] = (sdisp_mid_p -   sdisp_ss).norm(passe_partout_size=4)
        res_sca_sq_ground[i, 5] = (sdisp_euler_m - sdisp_ss).norm(passe_partout_size=4)
        res_sca_sq_ground[i, 6] = (sdisp_heun -    sdisp_ss).norm(passe_partout_size=4)
        res_sca_sq_ground[i, 7] = (sdisp_heun_m -  sdisp_ss).norm(passe_partout_size=4)
        res_sca_sq_ground[i, 8] = (sdisp_rk4 -     sdisp_ss).norm(passe_partout_size=4)

        ### 2) Scaling squaring polyaffine ground truth

        res_sca_sq_pa_ground[i, 0] = svf_0.norm()
        res_sca_sq_pa_ground[i, 1] = sdisp_ss_pa.norm()
        res_sca_sq_pa_ground[i, 2] = (sdisp_ss -      sdisp_ss_pa).norm(passe_partout_size=4)
        res_sca_sq_pa_ground[i, 3] = (sdisp_euler -   sdisp_ss_pa).norm(passe_partout_size=4)
        res_sca_sq_pa_ground[i, 4] = (sdisp_mid_p -   sdisp_ss_pa).norm(passe_partout_size=4)
        res_sca_sq_pa_ground[i, 5] = (sdisp_euler_m - sdisp_ss_pa).norm(passe_partout_size=4)
        res_sca_sq_pa_ground[i, 6] = (sdisp_heun -    sdisp_ss_pa).norm(passe_partout_size=4)
        res_sca_sq_pa_ground[i, 7] = (sdisp_heun_m -  sdisp_ss_pa).norm(passe_partout_size=4)
        res_sca_sq_pa_ground[i, 8] = (sdisp_rk4 -     sdisp_ss_pa).norm(passe_partout_size=4)

        ### 3) Euler ground truth

        res_euler_ground[i, 0] = svf_0.norm()
        res_euler_ground[i, 1] = sdisp_euler.norm()
        res_euler_ground[i, 2] = (sdisp_ss -      sdisp_euler).norm(passe_partout_size=4)
        res_euler_ground[i, 3] = (sdisp_ss_pa -   sdisp_euler).norm(passe_partout_size=4)
        res_euler_ground[i, 4] = (sdisp_mid_p -   sdisp_euler).norm(passe_partout_size=4)
        res_euler_ground[i, 5] = (sdisp_euler_m - sdisp_euler).norm(passe_partout_size=4)
        res_euler_ground[i, 6] = (sdisp_heun -    sdisp_euler).norm(passe_partout_size=4)
        res_euler_ground[i, 7] = (sdisp_heun_m -  sdisp_euler).norm(passe_partout_size=4)
        res_euler_ground[i, 8] = (sdisp_rk4 -     sdisp_euler).norm(passe_partout_size=4)

        ### 5) Midpoint ground truth

        res_midpoint_ground[i, 0] = svf_0.norm()
        res_midpoint_ground[i, 1] = sdisp_mid_p.norm()
        res_midpoint_ground[i, 2] = (sdisp_ss -      sdisp_mid_p).norm(passe_partout_size=4)
        res_midpoint_ground[i, 3] = (sdisp_ss_pa -   sdisp_mid_p).norm(passe_partout_size=4)
        res_midpoint_ground[i, 4] = (sdisp_euler -   sdisp_mid_p).norm(passe_partout_size=4)
        res_midpoint_ground[i, 5] = (sdisp_euler_m - sdisp_mid_p).norm(passe_partout_size=4)
        res_midpoint_ground[i, 6] = (sdisp_heun -    sdisp_mid_p).norm(passe_partout_size=4)
        res_midpoint_ground[i, 7] = (sdisp_heun_m -  sdisp_mid_p).norm(passe_partout_size=4)
        res_midpoint_ground[i, 8] = (sdisp_rk4 -     sdisp_mid_p).norm(passe_partout_size=4)

        ### 4) Euler modified ground truth

        res_euler_mod_ground[i, 0] = svf_0.norm()
        res_euler_mod_ground[i, 1] = sdisp_euler_m.norm()
        res_euler_mod_ground[i, 2] = (sdisp_ss -     sdisp_euler_m).norm(passe_partout_size=4)
        res_euler_mod_ground[i, 3] = (sdisp_ss_pa -  sdisp_euler_m).norm(passe_partout_size=4)
        res_euler_mod_ground[i, 4] = (sdisp_mid_p -  sdisp_euler_m).norm(passe_partout_size=4)
        res_euler_mod_ground[i, 5] = (sdisp_euler -  sdisp_euler_m).norm(passe_partout_size=4)
        res_euler_mod_ground[i, 6] = (sdisp_heun -   sdisp_euler_m).norm(passe_partout_size=4)
        res_euler_mod_ground[i, 7] = (sdisp_heun_m - sdisp_euler_m).norm(passe_partout_size=4)
        res_euler_mod_ground[i, 8] = (sdisp_rk4 -    sdisp_euler_m).norm(passe_partout_size=4)

        ### 6) Heun ground truth

        res_heun_ground[i, 0] = svf_0.norm()
        res_heun_ground[i, 1] = sdisp_heun.norm()
        res_heun_ground[i, 2] = (sdisp_ss -      sdisp_heun).norm(passe_partout_size=4)
        res_heun_ground[i, 3] = (sdisp_ss_pa -   sdisp_heun).norm(passe_partout_size=4)
        res_heun_ground[i, 4] = (sdisp_mid_p -   sdisp_heun).norm(passe_partout_size=4)
        res_heun_ground[i, 5] = (sdisp_euler -   sdisp_heun).norm(passe_partout_size=4)
        res_heun_ground[i, 6] = (sdisp_euler_m - sdisp_heun).norm(passe_partout_size=4)
        res_heun_ground[i, 7] = (sdisp_heun_m -  sdisp_heun).norm(passe_partout_size=4)
        res_heun_ground[i, 8] = (sdisp_rk4 -     sdisp_heun).norm(passe_partout_size=4)

        ### 7) Heun modified ground truth

        res_heun_mod_ground[i, 0] = svf_0.norm()
        res_heun_mod_ground[i, 1] = sdisp_heun.norm()
        res_heun_mod_ground[i, 2] = (sdisp_ss -      sdisp_heun_m).norm(passe_partout_size=4)
        res_heun_mod_ground[i, 3] = (sdisp_ss_pa -   sdisp_heun_m).norm(passe_partout_size=4)
        res_heun_mod_ground[i, 4] = (sdisp_mid_p -   sdisp_heun_m).norm(passe_partout_size=4)
        res_heun_mod_ground[i, 5] = (sdisp_euler -   sdisp_heun_m).norm(passe_partout_size=4)
        res_heun_mod_ground[i, 6] = (sdisp_euler_m - sdisp_heun_m).norm(passe_partout_size=4)
        res_heun_mod_ground[i, 7] = (sdisp_heun -    sdisp_heun_m).norm(passe_partout_size=4)
        res_heun_mod_ground[i, 8] = (sdisp_rk4 -     sdisp_heun_m).norm(passe_partout_size=4)

        ### 8) RK 4 ground truth

        res_r_k_4_ground[i, 0] = svf_0.norm()
        res_r_k_4_ground[i, 1] = sdisp_rk4.norm()
        res_r_k_4_ground[i, 2] = (sdisp_ss -      sdisp_rk4).norm(passe_partout_size=4)
        res_r_k_4_ground[i, 3] = (sdisp_ss_pa -   sdisp_rk4).norm(passe_partout_size=4)
        res_r_k_4_ground[i, 4] = (sdisp_mid_p -   sdisp_rk4).norm(passe_partout_size=4)
        res_r_k_4_ground[i, 5] = (sdisp_euler -   sdisp_rk4).norm(passe_partout_size=4)
        res_r_k_4_ground[i, 6] = (sdisp_euler_m - sdisp_rk4).norm(passe_partout_size=4)
        res_r_k_4_ground[i, 7] = (sdisp_heun -    sdisp_rk4).norm(passe_partout_size=4)
        res_r_k_4_ground[i, 8] = (sdisp_heun_m -  sdisp_rk4).norm(passe_partout_size=4)

    reordered_res_sca_sq_ground_for_boxplot = [list(res_sca_sq_ground[:, 2])] +\
        [list(res_sca_sq_ground[:, 3])] + [list(res_sca_sq_ground[:, 4])] +\
        [list(res_sca_sq_ground[:, 5])] + [list(res_sca_sq_ground[:, 6])] +\
        [list(res_sca_sq_ground[:, 7])] + [list(res_sca_sq_ground[:, 8])]

    reordered_res_sca_sq_pa_ground_for_boxplot = [list(res_sca_sq_pa_ground[:, 2])] +\
        [list(res_sca_sq_pa_ground[:, 3])] + [list(res_sca_sq_pa_ground[:, 4])] +\
        [list(res_sca_sq_pa_ground[:, 5])] + [list(res_sca_sq_pa_ground[:, 6])] +\
        [list(res_sca_sq_pa_ground[:, 7])] + [list(res_sca_sq_pa_ground[:, 8])]

    reordered_res_euler_ground_for_boxplot = [list(res_euler_ground[:, 2])] +\
        [list(res_euler_ground[:, 3])] + [list(res_euler_ground[:, 4])] +\
        [list(res_euler_ground[:, 5])] + [list(res_euler_ground[:, 6])] +\
        [list(res_euler_ground[:, 7])] + [list(res_euler_ground[:, 8])]

    reordered_res_midpoint_ground_for_boxplot = [list(res_midpoint_ground[:, 2])] +\
        [list(res_midpoint_ground[:, 3])] + [list(res_midpoint_ground[:, 4])] +\
        [list(res_midpoint_ground[:, 5])] + [list(res_midpoint_ground[:, 6])] +\
        [list(res_midpoint_ground[:, 7])] + [list(res_midpoint_ground[:, 8])]

    reordered_res_euler_mod_ground_for_boxplot = [list(res_euler_mod_ground[:, 2])] +\
        [list(res_euler_mod_ground[:, 3])] + [list(res_euler_mod_ground[:, 4])] +\
        [list(res_euler_mod_ground[:, 5])] + [list(res_euler_mod_ground[:, 6])] +\
        [list(res_euler_mod_ground[:, 7])] + [list(res_euler_mod_ground[:, 8])]

    reordered_res_heun_for_boxplot = [list(res_heun_ground[:, 2])] +\
        [list(res_heun_ground[:, 3])] + [list(res_heun_ground[:, 4])] +\
        [list(res_heun_ground[:, 5])] + [list(res_heun_ground[:, 6])] +\
        [list(res_heun_ground[:, 7])] + [list(res_heun_ground[:, 8])]

    reordered_res_heun_mod_for_boxplot = [list(res_heun_mod_ground[:, 2])] +\
        [list(res_heun_mod_ground[:, 3])] + [list(res_heun_mod_ground[:, 4])] +\
        [list(res_heun_mod_ground[:, 5])] + [list(res_heun_mod_ground[:, 6])] +\
        [list(res_heun_mod_ground[:, 7])] + [list(res_heun_mod_ground[:, 8])]

    reordered_res_r_k_4_for_boxplot = [list(res_r_k_4_ground[:, 2])] +\
        [list(res_r_k_4_ground[:, 3])] + [list(res_r_k_4_ground[:, 4])] +\
        [list(res_r_k_4_ground[:, 5])] + [list(res_r_k_4_ground[:, 6])] +\
        [list(res_r_k_4_ground[:, 7])] + [list(res_r_k_4_ground[:, 8])]

    print 'Data Computed'

    np.save(path_to_reordered_res_sca_sq_ground_for_boxplot, reordered_res_sca_sq_ground_for_boxplot)
    np.save(path_to_reordered_res_sca_sq_pa_ground_for_boxplot, reordered_res_sca_sq_pa_ground_for_boxplot)
    np.save(path_to_reordered_res_euler_ground_for_boxplot, reordered_res_euler_ground_for_boxplot)
    np.save(path_to_reordered_res_midpoint_ground_for_boxplot, reordered_res_midpoint_ground_for_boxplot)
    np.save(path_to_reordered_res_euler_mod_ground_for_boxplot, reordered_res_euler_mod_ground_for_boxplot)
    np.save(path_to_reordered_res_heun_for_boxplot, reordered_res_heun_for_boxplot)
    np.save(path_to_reordered_res_heun_mod_for_boxplot, reordered_res_heun_mod_for_boxplot)
    np.save(path_to_reordered_res_r_k_4_for_boxplot, reordered_res_r_k_4_for_boxplot)

    print 'data saved'

else:
    reordered_res_sca_sq_ground_for_boxplot    = np.load(path_to_reordered_res_sca_sq_ground_for_boxplot)
    reordered_res_sca_sq_pa_ground_for_boxplot = np.load(path_to_reordered_res_sca_sq_pa_ground_for_boxplot)
    reordered_res_euler_ground_for_boxplot     = np.load(path_to_reordered_res_euler_ground_for_boxplot)
    reordered_res_midpoint_ground_for_boxplot  = np.load(path_to_reordered_res_midpoint_ground_for_boxplot)
    reordered_res_euler_mod_ground_for_boxplot = np.load(path_to_reordered_res_euler_mod_ground_for_boxplot)
    reordered_res_heun_for_boxplot             = np.load(path_to_reordered_res_heun_for_boxplot)
    reordered_res_heun_mod_for_boxplot         = np.load(path_to_reordered_res_heun_mod_for_boxplot)
    reordered_res_r_k_4_for_boxplot            = np.load(path_to_reordered_res_r_k_4_for_boxplot)

    print 'Data Loaded'


##############
### Viewer ###
##############

title_input_list = ['Sc and Sq',
                    'Poly Sc and Sq',
                    'Euler',
                    'Midpoint ',
                    'Euler mod',
                    'heun',
                    'Heun mod',
                    'Runge-Kutta 4']

if 0:  # scaling and squaring ground
    custom_boxplot(reordered_res_sca_sq_ground_for_boxplot, fig_tag=0,
                   x_labels=remove_k(title_input_list, 0),
                   y_axis_label='Error (Scaling Squaring ground truth)',
                   x_axis_label='Numerical Methods')

if 0:  # polyaffine scaling and squaring ground
    custom_boxplot(reordered_res_sca_sq_pa_ground_for_boxplot, fig_tag=1,
                   x_labels=remove_k(title_input_list, 1),
                   y_axis_label='Error (polyaffine scaling squaring ground truth)',
                   x_axis_label='Numerical methods')

if 0:  # Euler ground
    custom_boxplot(reordered_res_euler_ground_for_boxplot, fig_tag=2,
                   x_labels=remove_k(title_input_list, 2),
                   y_axis_label='Error (Euler ground truth)',
                   x_axis_label='Numerical methods')

if 0:  # Midpoint ground
    custom_boxplot(reordered_res_midpoint_ground_for_boxplot, fig_tag=3,
                   x_labels=remove_k(title_input_list, 3),
                   y_axis_label='Error (midpoint modified ground truth)',
                   x_axis_label='Numerical Methods')

if 0:  # Euler modified ground
    custom_boxplot(reordered_res_euler_mod_ground_for_boxplot, fig_tag=4,
                   x_labels=remove_k(title_input_list, 4),
                   y_axis_label='Error (Euler modified ground truth)',
                   x_axis_label='Numerical Methods')

if 0:  # Heun modified ground
    custom_boxplot(reordered_res_heun_for_boxplot, fig_tag=5,
                   x_labels=remove_k(title_input_list, 4),
                   y_axis_label='Error (Euler modified ground truth)',
                   x_axis_label='Numerical Methods')

if 0:  # Heun mod modified ground
    custom_boxplot(reordered_res_heun_mod_for_boxplot, fig_tag=6,
                   x_labels=remove_k(title_input_list, 4),
                   y_axis_label='Error (Euler modified ground truth)',
                   x_axis_label='Numerical Methods')

if 0:  # Runge-Kutta 4
    custom_boxplot(reordered_res_r_k_4_for_boxplot, fig_tag=7,
                   x_labels=remove_k(title_input_list, 5),
                   y_axis_label='Error (RK4 ground truth)',
                   x_axis_label='Numerical Methods')


if 1:  # Print different ground truth in one!
    all_data = [reordered_res_sca_sq_ground_for_boxplot,
                reordered_res_sca_sq_pa_ground_for_boxplot,
                reordered_res_euler_ground_for_boxplot,
                reordered_res_midpoint_ground_for_boxplot,
                reordered_res_euler_mod_ground_for_boxplot,
                reordered_res_heun_for_boxplot,
                reordered_res_heun_mod_for_boxplot,
                reordered_res_r_k_4_for_boxplot]

    all_boxes_labels = []

    for i in range(8):
        all_boxes_labels += [remove_k(title_input_list, i)]

    all_x_axis_labels = [''] * 8
    all_y_axis_labels = ['Error (Scaling Squaring ground truth)',
                         'Error (Polyaffine scal sq ground truth)',
                         'Error (Euler ground truth)',
                         'Error (midpoint modified ground truth)',
                         'Error (Euler modified ground truth)',
                         'Error (Heun ground truth)',
                         'Error (Heun modified ground truth)',
                         'Error (RK4 ground truth)']

    custom_n_boxplots(all_data, fig_tag=50,
                      n_row=2, n_col=4,
                      x_labels=all_boxes_labels,
                      x_axis_labels=all_x_axis_labels,
                      y_axis_labels=all_y_axis_labels)


plt.show()

